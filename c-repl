#!/usr/bin/python

import argparse
import cmd
import copy
import logging
import os
import re
import signal
import subprocess
import sys

VERSION = "0.1.2"
INDENT = "  "
CLANG = "clang"
FIND_HEADER = "./assets/find-header"

parser = argparse.ArgumentParser(
		description="For those who'd like to use C like an interpreted language but just don't want to install ANYTHING, caveman style.",
		epilog="To be fair, you still need to install 'clang' (any non-ancient version) and 'python' (which you obviously have if you can read this).")
parser.add_argument("-e", "--error-diag", help="attach full error diagnostic", action="store_true")
parser.add_argument("-o", "--out-path", help="set output path for code", type=str, default="/tmp/c-repl.c")
args = parser.parse_args()

class StdIncludePreproc():
    def __init__(self, path, depth):
        self.path = path
        self.depth = depth
        self.err = []
        self.commented = False

    def __repr__(self):
        incl_path = '/'.join(self.path.split('/')[-self.depth:])
        return "#include <{}>".format(incl_path)

    def get(self):
        out = ["* " + err_line for err_line in self.err]
        out += [self.__repr__()]
        if (self.commented) or (self.err):
            out = ["// " + l for l in out]
        return out

class Preproc():
    def __init__(self, s):
        self.s = s.strip()
        self.err = []
        self.commented = False

    def get(self):
        out = ["* " + err_line for err_line in self.err]
        out += [self.s]
        if (self.commented) or (self.err):
            out = ["// " + l for l in out]
        return out 

class Statement():
    def __init__(self, st):
        self.st = st
        self.err = []
        self.commented = False

    def get(self):
        out = ["* " + err_line for err_line in self.err]
        out += [self.st]
        if (self.commented) or (self.err):
            out = ["// " + l for l in out]
        return out

class Block():
    def __init__(self, head):
        self.head = head.strip()
        self.children = []
        self.repr = self.head
        self.err = []
        self.commented = False
        self.kind = "?"
        self.name = ""

        if (not self.head):
            self.kind = "block"
            self.repr = "(block)"
        else:
            re_block_kw = re.search("^(for|while|else if|if|case) *\\(", self.head)
            if (re_block_kw):
                self.kind = re_block_kw.group(1)
            else:
                re_block_else = re.search("^else$", self.head)
                if (re_block_else):
                    self.kind = "else"
                else:
                    self.kind = "function"
                    re_func_name = re.search("([a-zA-Z_0-9]+) *\\(", self.head)
                    if (re_func_name):
                        self.name = re_func_name.group(1)
        
        if (self.name == "main"):
            self.repr = ""

    def add(self, child):
        self.children += [child]

    def pop(self):
        self.children = self.children[:-1]

    def get(self):
        out = ["* " + err_line for err_line in self.err]
        out += ["{}{{".format(self.head + " " if (self.head) else "")]
        for child in self.children:
            child_lines = child.get()
            for child_line in child_lines:
                out += ["{}{}".format(INDENT, child_line)]
        out += ["}"]
        if (self.commented) or (self.err):
            out = ["// " + l for l in out]
        return out

class TranslationUnit():
    def __init__(self, out_path=None):
        self.out_path = out_path
        self.incls = []
        self.funcs = []
        self.main = Block("int main()")

    def get(self):
        out = []
        for incl in self.incls:
            out += incl.get()
        if (self.incls): out += [""]
        for func in self.funcs:
            out += func.get()
            out += [""]
        out += self.main.get()
        return out

    def print(self):
        with open(self.out_path, 'w') as f:
            f.writelines([l + '\n' for l in self.get()])
        return True

class REPLoop(cmd.Cmd):
    try:
        c_repl_moddate = subprocess.check_output(["LANG=en date -r {} +\"%d %b %Y %H:%M:%S\"".format(__file__)], shell=True).decode().strip()
    except:
        c_repl_moddate = "?? ??? ???? ??:??:??"

    try:
        clang_version_str = subprocess.check_output(["clang -dM -E -x c /dev/null | grep __VERSION__"], shell=True).decode().strip()
        clang_version = clang_version_str.split(' ', 2)[2].replace('"', '')
    except:
        clang_version = "Clang rersion I♬don't♪know"

    intro = "C-REPL {} (main, {}) [{}] on linux\n".format(VERSION, c_repl_moddate, clang_version) + \
            "Type \"%print\" for the working code or \"%exit\" to exit."
    prompt = ">>> "

    def __init__(self, src_path="/tmp/c-repl.c", exe_path="/tmp/c-repl"):
        super().__init__()

        self.src_path = src_path
        self.exe_path = exe_path
        self.tu = TranslationUnit(out_path=src_path)
        self.stack = [self.tu.main]

        self.wait_subproc = False
        self.dfn_sigint = signal.signal(signal.SIGINT, self.interrupt)
        self.prev_exe_out = ""

        open(self.src_path, 'w').close()
        open(self.exe_path, 'w').close()

    def exit(self):
        print("Goodbye ᕕ(⌐■_■)ᕗ ♪♬")
        exit(0)

    def interrupt(self, sig, frame):
        if (not self.wait_subproc):
            print()
            self.exit()

    def run(self, *args, **kwargs):
        self.wait_subproc = True
        try:
            ret = subprocess.run(*args, **kwargs)
        except subprocess.CalledProcessError:
            pass
        self.wait_subproc = False
        return ret

    def input(self, *args, **kwargs):
        prev_sighandler = signal.signal(signal.SIGINT, self.dfn_sigint)
        try:
            ret = input(*args, **kwargs)
        except KeyboardInterrupt:
            ret = ""
        signal.signal(signal.SIGINT, prev_sighandler)
        return ret

    def is_system_cmd(self, line):
        if (line[0:1] == '%'):
            return line

    def is_preproc(self, line):
        return (re.search("^#.*", line.strip()) != None)

    def get_block_head(self, line):
        line = line.strip()

        re_init_list = re.search("= *{", line)
        if (re_init_list):
            return None

        re_block_head = re.search("([^{]*){", line)
        if (re_block_head):
            return re_block_head.group(1).strip()
        else:
            return None

    def get_block_close(self, line):
        line = line.strip()
        re_block_close = re.search("^(}+)$", line)
        if (re_block_close):
            return re_block_close.group(1).count('}')
        else:
            return None

    def precmd(self, line):
        if (not self.is_system_cmd(line)):
            return line

        tokens = line.split()
        
        if (tokens[0] == "%exit"):
            self.exit()
        elif (tokens[0] == "%print"):
            if (len(tokens) == 1):
                with open(self.src_path, 'r') as f:
                    src_lines = f.readlines()
                for src_line in src_lines:
                    print(src_line[:-1])
            else:
                symbol_name = tokens[1]
                options = tokens[2].split(',') if (len(tokens) >= 3) else ""
                type_str = "?"
                value_str = "?"

                ast_out = subprocess.run([CLANG, "-x", "c", "-fsyntax-only", "-Xclang", "-ast-dump", self.src_path], capture_output=True)
                ast_lines = ast_out.stdout.decode().split('\n')

                for ast_line in ast_lines:
                    re_type = re.search("Decl .* {} '([^']+)'".format(symbol_name), ast_line)
                    if (re_type):
                        type_str = re_type.group(1)
                        break

                # TranslationUnit has no concept of a stack (or the context),
                # so add the print statement to the current TranslationUnit,
                # copy it, and restore the TranslationUnit. Dirty hack I guess.
                if ("ptr" in options):
                    self.stack[-1].add(Statement("AUTO_PRINT((void *){});".format(symbol_name)))
                elif (any(o.startswith("len=") for o in options)):
                    len_option = [o for o in options if o.startswith("len=")][-1]
                    n_len = len_option.split("=")[1]
                    self.stack[-1].add(Statement(""" 
                        RAW_PRINT("[ ");
                        for (int i = 0; i < {}; i++) {{
                            AUTO_PRINT({}[i]);
                            if (i < {} - 1)
                                RAW_PRINT(", ");
                            else
                                RAW_PRINT(" ]");
                        }}""".format(n_len, symbol_name, n_len)))
                else:
                    self.stack[-1].add(Statement("AUTO_PRINT({});".format(symbol_name)))
                tu_copy = copy.deepcopy(self.tu)
                self.stack[-1].pop()

                tmp_src_path = "/tmp/c-repl.tmp.c"
                tmp_exe_path = "/tmp/c-repl.tmp"
                tu_copy.out_path = tmp_src_path
                
                tu_copy.incls += [Preproc("#include \"{}\"".format(os.path.realpath("./assets/print.h")))]
                assert(tu_copy.print())

                # TODO: Weirdly, Python subprocess appears to only work with the
                # redirection with the FD "3" (or probably the next free FD).
                # For now, use FD 3 and fix it later.
                clang_out = self.run([CLANG, "-x", "c", tmp_src_path, "-o", tmp_exe_path], check=False, capture_output=True)
                
                if (clang_out.returncode == 0):
                    exe_out = self.run("{} 3>&1 >/dev/null 2>&1".format(tmp_exe_path), shell=True, capture_output=True)
                    if (exe_out.returncode == 0):
                        value_str = exe_out.stdout.decode()

                print("{} = ({}) {}".format(symbol_name, type_str, value_str))

                # TODO: if type is enum, parse ast harder, print it, and return.
                # TODO: inject code to print value to fd X (e.g., 12345)
                #        - cast to (void*) if the option 'addr' is set.
                #        - print elem-by-elem if the option 'len=<len>' is set.
                #        - if type is struct, print field-by-field.
        else:
            logging.warning("unrecognized system command.")

        return line 
    
    def default(self, line):
        if (line == "EOF"):
            self.interrupt(None, None)
        elif (self.is_system_cmd(line)):
            return

        # Identify the type of input.
        if (self.is_preproc(line)):
            cur_obj = Preproc(line)
            self.tu.incls += [cur_obj]
        else:
            block_head = self.get_block_head(line)
            n_block_close = self.get_block_close(line)
            if (block_head != None):
                cur_obj = Block(block_head)
                if (cur_obj.kind == "function"):
                    func_dup = False
                    for f in self.tu.funcs:
                        if (f.name == cur_obj.name):
                            func_dup = True
                            break
                    if (func_dup):
                        logging.error("function '{}' already defined.".format(cur_obj.name))
                        return
                    else:
                        self.tu.funcs += [cur_obj]
                else:
                    self.stack[-1].add(cur_obj)
                self.stack += [cur_obj]
            elif (n_block_close != None):
                cur_obj = None
                if (n_block_close >= len(self.stack)):
                    self.exit()
                self.stack = self.stack[:-n_block_close]
            else:
                cur_obj = Statement(line.strip())
                self.stack[-1].add(cur_obj)

        # First compile attempt.
        assert(self.tu.print())
        clang_out = self.run([CLANG, "-x", "c", self.src_path, "-o", self.exe_path], check=False, capture_output=True)

        # Obvious library function not included?
        # TODO: match this to the compiler flag.
        re_impl_lib_func = re.search("(implicitly declaring library function|call to undeclared library function) '([a-zA-Z_0-9]+)'", clang_out.stderr.decode())
        auto_included = False
        if (re_impl_lib_func):
            impl_func_name = re_impl_lib_func.group(2)
            logging.warning("function '{}' not included.".format(impl_func_name))
            re_incl_suggest = re.search("include the header <([a-zA-Z_0-9/\\.]+)>", clang_out.stderr.decode())
            if (re_incl_suggest):
                auto_included = True
                suggested_header_path = re_incl_suggest.group(1)
                logging.warning("automatically including suggested header '{}'...".format(suggested_header_path))
                self.tu.incls += [StdIncludePreproc(suggested_header_path, 0)]
            else:
                assert(False)

        # Less obvious function not included?
        # TODO: match this to the compiler flag.
        re_impl_func = re.search("(implicit declaration of function|call to undeclared function) '([a-zA-Z_0-9]+)'", clang_out.stderr.decode())
        if (re_impl_func or (re_impl_lib_func and not auto_included)):
            impl_func_name = re_impl_func.group(2) if (re_impl_func) else re_impl_lib_func.group(2)
            logging.warning("function '{}' not included.".format(impl_func_name))
            find_header_out = self.run([FIND_HEADER, "find", impl_func_name, "-f"], check=False, capture_output=True)
            find_header_out_stdout = find_header_out.stdout.decode().strip()
            if (find_header_out_stdout):
                cand_headers = [StdIncludePreproc(e.split('\t')[0], int(e.split('\t')[1])) for e in find_header_out_stdout.split('\n')]
                for i, cand_header in enumerate(cand_headers):
                    logging.warning("[{}] {} (at '{}')".format(i, str(cand_header), cand_header.path))
                logging.warning("which to include? ")
                header_num = self.input()
                try:
                    self.tu.incls += [cand_headers[int(header_num)]]
                except:
                    logging.error("header inclusion failed.")
            else:
                logging.warning("cannot find header.")

        # Second compile attempt.
        assert(self.tu.print())
        clang_out = self.run([CLANG, "-x", "c", self.src_path, "-Werror=implicit-function-declaration", "-o", self.exe_path], check=False, capture_output=True)

        # Execute.
        if (clang_out.returncode == 0):
            exe_out = self.run([self.exe_path], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            new_exe_out = exe_out.stdout.decode().strip()
            incl_exe_out = new_exe_out.removeprefix(self.prev_exe_out).strip()
            self.prev_exe_out = new_exe_out
            if (incl_exe_out):
                print(incl_exe_out)
            else:
                # TODO: print the return value of the last statement.
                pass
            if (exe_out.returncode != 0):
                cur_obj.err = ["error: (unknown runtime error)"]
                assert(self.tu.print())
                if (self.stack[-1] == cur_obj):
                    self.stack = self.stack[:-1]
                logging.warning("unknown runtime error occurred.")
        else:
            print(clang_out.stderr.decode())
            err_str = clang_out.stderr.decode().strip()
            re_error_msg = re.search("(error: .*)\n", err_str)
            if (not args.error_diag and re_error_msg):
                err_str = re_error_msg.group(1)
            else:
                err_str = re.sub("^.* error:", "error:", err_str)
                err_str = re.sub("\n.*error.*generated.*", "", err_str)
            cur_obj.err = [l.strip() for l in err_str.split('\n')]
            assert(self.tu.print())
            if (self.stack[-1] == cur_obj):
                self.stack = self.stack[:-1]

    def postcmd(self, stop, line):
        prompt_head = self.stack[-1].repr
        if (prompt_head): prompt_head += " "
        self.prompt = "{}>>> ".format(prompt_head)
        return stop


repl = REPLoop(src_path=args.out_path)
repl.cmdloop()

# TODO: keyboard up to navigate previous statements
# TODO: accept base code
# TODO: support incremental build
# TODO: print last return value (if nothing is to print)
# TODO: replay input after the first time
