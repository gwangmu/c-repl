#!/usr/bin/python

import argparse
import logging
import re
import signal
import subprocess
import sys

VERSION = "v0.1"
INDENT = "  "
CC = "clang"
FIND_HEADER = "./find-header"

parser = argparse.ArgumentParser()
parser.add_argument("-e", "--error-diag", help="attach full error diagnostic", action="store_true")
parser.add_argument("-o", "--out-path", help="set output path for code", type=str, default="/tmp/c-repl.c")
args = parser.parse_args()

class StdIncludePreproc():
    def __init__(self, path, depth):
        self.path = path
        self.depth = depth
        self.err = []
        self.commented = False

    def __repr__(self):
        incl_path = '/'.join(self.path.split('/')[-self.depth:])
        return "#include <{}>".format(incl_path)

    def get(self):
        out = ["* " + err_line for err_line in self.err]
        out += [self.__repr__()]
        if (self.commented) or (self.err):
            out = ["// " + l for l in out]
        return out

class Preproc():
    def __init__(self, s):
        self.s = s.strip()
        self.err = []
        self.commented = False

    def get(self):
        out = ["* " + err_line for err_line in self.err]
        out += [self.s]
        if (self.commented) or (self.err):
            out = ["// " + l for l in out]
        return out 

class Statement():
    def __init__(self, st):
        self.st = st
        self.err = []
        self.commented = False

    def get(self):
        out = ["* " + err_line for err_line in self.err]
        out += [self.st]
        if (self.commented) or (self.err):
            out = ["// " + l for l in out]
        return out

class Block():
    def __init__(self, head):
        self.head = head.strip()
        self.children = []
        self.repr = self.head
        self.err = []
        self.commented = False
        self.kind = "?"
        self.name = ""

        if (not self.head):
            self.kind = "block"
            self.repr = "(block)"
        else:
            re_block_kw = re.search("^(for|while|if|else|case) *\(", self.head)
            if (re_block_kw):
                self.kind = re_block_kw.group(1)
            else:
                self.kind = "function"
                re_func_name = re.search("([a-zA-Z_0-9]+) *\(", self.head)
                if (re_func_name):
                    self.name = re_func_name.group(1)
        
        if (self.name == "main"):
            self.repr = ""

    def add(self, child):
        self.children += [child]

    def get(self):
        out = ["* " + err_line for err_line in self.err]
        out += ["{}{{".format(self.head + " " if (self.head) else "")]
        for child in self.children:
            child_lines = child.get()
            for child_line in child_lines:
                out += ["{}{}".format(INDENT, child_line)]
        out += ["}"]
        if (self.commented) or (self.err):
            out = ["// " + l for l in out]
        return out

class TranslationUnit():
    def __init__(self, out_path=None):
        self.out_path = out_path
        self.incls = []
        self.funcs = []
        self.main = Block("int main()")

    def get(self):
        out = []
        for incl in self.incls:
            out += incl.get()
            out += [""]
        for func in self.funcs:
            out += func.get()
            out += [""]
        out += self.main.get()
        return out

    def print(self):
        with open(self.out_path, 'w') as f:
            f.writelines([l + '\n' for l in self.get()])
        return True

class REPLoop():
    def __init__(self, src_path="/tmp/c-repl.c", exe_path="/tmp/c-repl"):
        self.src_path = src_path
        self.exe_path = exe_path
        self.tu = TranslationUnit(out_path=src_path)
        self.stack = [self.tu.main]

        self.wait_subproc = False
        self.dfn_sigint = signal.signal(signal.SIGINT, self.interrupt)

    def interrupt(self, sig, frame):
        if (not self.wait_subproc):
            print("\nGoodbye...")
            exit(0)

    def run(self, *args, **kwargs):
        self.wait_subproc = True
        try:
            ret = subprocess.run(*args, **kwargs)
        except subprocess.CalledProcessError:
            pass
        self.wait_subproc = False
        return ret

    def input(self, *args, **kwargs):
        prev_sighandler = signal.signal(signal.SIGINT, self.dfn_sigint)
        try:
            ret = input(*args, **kwargs)
        except KeyboardInterrupt:
            ret = ""
        signal.signal(signal.SIGINT, prev_sighandler)
        return ret

    def system(self, line):
        line = line.strip()

        if (line[0:1] != '%'):
            return False
        
        if (line[1:] == "exit"):
            self.interrupt(None, None)
        elif (line[1:] == "print"):
            with open(self.src_path, 'r') as f:
                lines = f.readlines()
            for line in lines:
                print(line[:-1])
        else:
            logging.warning("unrecognized system command.")

        return True

    def is_preproc(self, line):
        return (re.search("#.*", line.strip()) != None)

    def get_block_head(self, line):
        line = line.strip()
        re_block_head = re.search("([^{]*){", line)
        if (re_block_head):
            return re_block_head.group(1).strip()
        else:
            return None

    def get_block_close(self, line):
        line = line.strip()
        re_block_close = re.search("}+", line)
        if (re_block_close):
            return line.count('}')
        else:
            return None
    
    def loop(self):
        prev_exe_out = ""
        while True:
            print("{} > ".format(self.stack[-1].repr), end='')
            try:
                line = input()
            except EOFError:
                self.interrupt(None, None)

            if (self.system(line)):
                continue

            # Identify the type of input.
            if (self.is_preproc(line)):
                cur_obj = Preproc(line)
                self.tu.incls += [cur_obj]
            else:
                block_head = self.get_block_head(line)
                n_block_close = self.get_block_close(line)
                if (block_head != None):
                    cur_obj = Block(block_head)
                    if (cur_obj.kind == "function"):
                        for f in self.tu.funcs:
                            if (f.name == cur_obj.name):
                                f.commented = True
                        self.tu.funcs += [cur_obj]
                    else:
                        self.stack[-1].add(cur_obj)
                    self.stack += [cur_obj]
                elif (n_block_close != None):
                    cur_obj = None
                    if (n_block_close >= len(self.stack)):
                        self.interrupt(None, None)
                    self.stack = self.stack[:-n_block_close]
                else:
                    cur_obj = Statement(line.strip())
                    self.stack[-1].add(cur_obj)

            # First compile attempt.
            assert(self.tu.print())
            cc_out = self.run([CC, self.src_path, "-o", self.exe_path], check=False, capture_output=True)

            # Obvious library function not included?
            re_impl_lib_func = re.search("implicitly declaring library function '([a-zA-Z_0-9]+)'", cc_out.stderr.decode())
            if (re_impl_lib_func):
                impl_func_name = re_impl_lib_func.group(1)
                logging.warning("function '{}' not included.".format(impl_func_name))
                re_incl_suggest = re.search("include the header <([a-zA-Z_0-9/\.]+)>", cc_out.stderr.decode())
                if (re_incl_suggest):
                    suggested_header_path = re_incl_suggest.group(1)
                    logging.warning("automatically including suggested header '{}'...".format(suggested_header_path))
                    self.tu.incls += [StdIncludePreproc(suggested_header_path, 0)]
                else:
                    assert(False)

            # Less obvious function not included?
            re_impl_func = re.search("implicit declaration of function '([a-zA-Z_0-9]+)'", cc_out.stderr.decode())
            if (re_impl_func):
                impl_func_name = re_impl_func.group(1)
                logging.warning("function '{}' not included.".format(impl_func_name))
                find_header_out = self.run([FIND_HEADER, "find", impl_func_name, "-f"], check=False, capture_output=True)
                find_header_out_stdout = find_header_out.stdout.decode().strip()
                if (find_header_out_stdout):
                    cand_headers = [StdIncludePreproc(e.split('\t')[0], int(e.split('\t')[1])) for e in find_header_out_stdout.split('\n')]
                    for i, cand_header in enumerate(cand_headers):
                        logging.warning("[{}] {} (at '{}')".format(i, str(cand_header), cand_header.path))
                    logging.warning("which to include? ")
                    header_num = self.input()
                    try:
                        self.tu.incls += [cand_headers[int(header_num)]]
                    except:
                        logging.error("header inclusion failed.")
                else:
                    logging.warning("cannot find header.")

            # Second compile attempt.
            assert(self.tu.print())
            cc_out = self.run([CC, self.src_path, "-Werror=implicit-function-declaration", "-o", self.exe_path], check=False, capture_output=True)

            # Execute.
            if (cc_out.returncode == 0):
                exe_out = self.run([self.exe_path], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                new_exe_out = exe_out.stdout.decode().strip()
                incl_exe_out = new_exe_out.removeprefix(prev_exe_out).strip()
                prev_exe_out = new_exe_out
                if (incl_exe_out):
                    print(incl_exe_out)
                else:
                    # TODO: print the return value of the last statement.
                    pass
                if (exe_out.returncode != 0):
                    cur_obj.err = ["error: (unknown runtime error)"]
                    assert(self.tu.print())
                    logging.warning("unknown runtime error occurred.")
            else:
                print(cc_out.stderr.decode())
                err_str = cc_out.stderr.decode().strip()
                re_error_msg = re.search("(error: .*)\n", err_str)
                if (not args.error_diag and re_error_msg):
                    err_str = re_error_msg.group(1)
                else:
                    err_str = re.sub("^.* error:", "error:", err_str)
                    err_str = re.sub("\n.*error.*generated.*", "", err_str)
                cur_obj.err = [l.strip() for l in err_str.split('\n')]
                assert(self.tu.print())

print("C REPL (version {})".format(VERSION))
repl = REPLoop(src_path=args.out_path)
repl.loop()

# TODO: keyboard up to navigate previous statements
# TODO: accept base code
