#!/usr/bin/python

import logging
import re
import subprocess

VERSION = "v0.1"
INDENT = "  "
CC = "clang"
FIND_HEADER = "./find-header"

class StdIncludePath():
    def __init__(self, path, depth):
        self.path = path
        self.depth = depth

    def __repr__(self):
        incl_path = '/'.join(self.path.split('/')[-self.depth:])
        return "#include <{}>".format(incl_path) 

class Statement():
    def __init__(self, st, err=[]):
        self.st = st
        self.err = err

    def get(self):
        st_out = self.st if (not self.err) else "// " + self.st
        return ["// " + err_line for err_line in self.err] + [st_out]

class Block():
    def __init__(self, head):
        self.head = head
        self.children = []

    def add(self, child):
        self.children += [child]

    def get(self):
        out = []
        out += ["{} {{".format(self.head)]
        for child in self.children:
            child_lines = child.get()
            for child_line in child_lines:
                out += ["{}{}".format(INDENT, child_line)]
        out += ["}"]
        return out

class TranslationUnit():
    def __init__(self, out_path=None):
        self.out_path = out_path
        self.incls = []
        self.blks = []
        self.main = Block("int main()")

    def get(self):
        out = []
        for incl in self.incls:
            out += [str(incl)]
        if (self.blks):
            out += [""]
        for blk in self.blks:
            out += blk.get()
        out += [""]
        out += self.main.get()
        return out

    def print(self):
        try:
            with open(self.out_path, 'w') as f:
                f.writelines([l + '\n' for l in self.get()])
        except:
            logging.error("output failed.")
            return False
        return True

class REPLoop():
    def __init__(self, src_path="/tmp/c-repl.c", exe_path="/tmp/c-repl"):
        self.src_path = src_path
        self.exe_path = exe_path
        self.tu = TranslationUnit(out_path=src_path)
        self.cur_blk = self.tu.main
    
    def loop(self):
        prev_exe_out = ""
        while True:
            print("> ", end='')
            line = input()
            cur_st = Statement(line.strip())
            self.cur_blk.add(cur_st)

            # First compile attempt.
            assert(self.tu.print())
            cc_out = subprocess.run([CC, self.src_path, "-o", self.exe_path], check=False, capture_output=True)

            # Obvious library function not included?
            re_impl_lib_func = re.search("implicitly declaring library function '([a-zA-Z_0-9]+)'", cc_out.stderr.decode())
            if (re_impl_lib_func):
                impl_func_name = re_impl_lib_func.group(1)
                logging.warning("function '{}' not included.".format(impl_func_name))
                re_incl_suggest = re.search("include the header <([a-zA-Z_0-9/\.]+)>", cc_out.stderr.decode())
                if (re_incl_suggest):
                    suggested_header_path = re_incl_suggest.group(1)
                    logging.warning("automatically including suggested header '{}'...".format(suggested_header_path))
                    self.tu.incls += [StdIncludePath(suggested_header_path, 0)]
                else:
                    assert(False)

            # Less obvious function not included?
            re_impl_func = re.search("implicit declaration of function '([a-zA-Z_0-9]+)'", cc_out.stderr.decode())
            if (re_impl_func):
                impl_func_name = re_impl_func.group(1)
                logging.warning("function '{}' not included.".format(impl_func_name))
                find_header_out = subprocess.check_output([FIND_HEADER, "find", impl_func_name, "-f"], text=True)
                if (find_header_out.strip()):
                    # TODO: cancel with Ctrl+C
                    cand_headers = [StdIncludePath(e.split('\t')[0], int(e.split('\t')[1])) for e in find_header_out.strip().split('\n')]
                    for i, cand_header in enumerate(cand_headers):
                        logging.warning("[{}] {} (at '{}')".format(i, str(cand_header), cand_header.path))
                    logging.warning("which to include? ")
                    header_num = input()
                    try:
                        self.tu.incls += [cand_headers[int(header_num)]]
                    except:
                        logging.error("header inclusion failed.")
                else:
                    logging.warning("cannot find header.")

            # Second compile attempt.
            assert(self.tu.print())
            cc_out = subprocess.run([CC, self.src_path, "-o", self.exe_path], check=False, capture_output=True)

            # Execute.
            if (cc_out.returncode == 0):
                exe_out = subprocess.run([self.exe_path], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                new_exe_out = exe_out.stdout.decode().strip()
                incl_exe_out = new_exe_out.removeprefix(prev_exe_out).strip()
                prev_exe_out = new_exe_out
                if (incl_exe_out):
                    print(incl_exe_out)
                else:
                    # TODO: print the return value of the last statement.
                    pass
                if (exe_out.returncode != 0):
                    cur_st.err = ["error: (unknown runtime error)"]
                    assert(self.tu.print())
                    logging.warning("unknown runtime error occurred.")
            else:
                print(cc_out.stderr.decode())
                err_str = cc_out.stderr.decode().strip()
                err_str = re.sub("^.* error:", "error:", err_str)
                err_str = re.sub(".*error.*generated.*", "", err_str)
                cur_st.err = [l.strip() for l in err_str.split('\n')]
                assert(self.tu.print())

print("C REPL (version {})".format(VERSION))
REPLoop().loop()

# TODO: Ctrl+C to quit.
# TODO: '%print' to print the current code.
# TODO: function, block support.
